package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/nikitarudakov/microenergy/api/model"
	"github.com/nikitarudakov/microenergy/api/runtime"
	"github.com/nikitarudakov/microenergy/internal/pb"
	"google.golang.org/protobuf/types/known/emptypb"
)

// RegisterEnergyResource is the resolver for the registerEnergyResource field.
func (r *mutationResolver) RegisterEnergyResource(ctx context.Context, in *model.RegisterEnergyResource) (*model.EnergyResource, error) {
	input := toProto(in, &pb.RegisterEnergyResourceInput{})
	input.Id = uuid.New().String()

	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
		Id: ptr(in.ProducerID),
	})
	if err != nil {
		return nil, fmt.Errorf("user with provided id %q MUST exist", in.ProducerID)
	}

	response, err := r.services.inventoryManagementService.RegisterEnergyResource(ctx, input)
	if err != nil {
		return nil, err
	}

	energyResource := fromProto(response, &model.EnergyResource{})

	energyResource.Producer = fromProto(user, &model.User{})

	return energyResource, nil
}

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, in *model.RegisterUser) (*model.User, error) {
	input := toProto(in, &pb.RegisterUserInput{})
	input.Id = uuid.New().String()

	user, err := r.services.userManagementService.RegisterUser(ctx, input)
	if err != nil {
		return nil, err
	}

	return fromProto(user, &model.User{}), nil
}

// PurchaseEnergy is the resolver for the purchaseEnergy field.
func (r *mutationResolver) PurchaseEnergy(ctx context.Context, in *model.PurchaseEnergy) (*model.EnergyResource, error) {
	energyResource, err := r.services.inventoryManagementService.SubtractEnergyResourceCapacity(
		ctx, toProto(in, &pb.SubtractEnergyResourceCapacityInput{}),
	)
	if err != nil {
		return nil, err
	}

	output := fromProto(energyResource, &model.EnergyResource{})

	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
		Id: ptr(energyResource.ProducerId),
	})
	if err != nil {
		return nil, fmt.Errorf("user with provided id %q MUST exist", energyResource.ProducerId)
	}

	output.Producer = fromProto(user, &model.User{})

	return output, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	response, err := r.services.userManagementService.FetchAllUsers(ctx, &emptypb.Empty{})
	if err != nil {
		return nil, err
	}

	var output []*model.User
	for _, user := range response.Users {
		output = append(output, fromProto(user, &model.User{}))
	}

	return output, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{Id: &id})
	if err != nil {
		return nil, err
	}

	return fromProto(user, &model.User{}), nil
}

// EnergyResources is the resolver for the energy_resources field.
func (r *queryResolver) EnergyResources(ctx context.Context) ([]*model.EnergyResource, error) {
	response, err := r.services.inventoryManagementService.FetchAllEnergyResources(ctx, &emptypb.Empty{})
	if err != nil {
		return nil, err
	}

	var output []*model.EnergyResource
	for _, er := range response.EnergyResources {
		// Convert from energy resource proto
		energyResource := fromProto(er, &model.EnergyResource{})

		// Fetch energy producer
		producer, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
			Id: ptr(er.ProducerId),
		})
		if err != nil {
			r.logger.Errorf("error fetching producer for energy resource %q: %s", er.Id, err)
			continue
		}

		// Convert to producer model
		energyResource.Producer = fromProto(producer, &model.User{})

		output = append(output, energyResource)
	}

	return output, nil
}

// Mutation returns runtime.MutationResolver implementation.
func (r *Resolver) Mutation() runtime.MutationResolver { return &mutationResolver{r} }

// Query returns runtime.QueryResolver implementation.
func (r *Resolver) Query() runtime.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) PurchaseEnergyFrom(ctx context.Context, in *model.PurchaseEnergyFrom) (*model.EnergyResource, error) {
	energyResource, err := r.services.inventoryManagementService.SubtractEnergyResourceCapacity(
		ctx, toProto(in, &pb.SubtractEnergyResourceCapacityInput{}))
}
*/
