package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/nikitarudakov/microenergy/api/model"
	"github.com/nikitarudakov/microenergy/api/runtime"
	"github.com/nikitarudakov/microenergy/internal/pb"
	"google.golang.org/protobuf/types/known/emptypb"
)

// RegisterEnergyResource is the resolver for the registerEnergyResource field.
func (r *mutationResolver) RegisterEnergyResource(ctx context.Context, in *model.RegisterEnergyResource) (*model.EnergyResource, error) {
	input := pb.ToProto(in, &pb.RegisterEnergyResourceInput{})
	input.Id = uuid.New().String()

	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
		Id: ptr(in.ProducerID),
	})
	if err != nil {
		return nil, fmt.Errorf("user with provided id %q MUST exist", in.ProducerID)
	}

	response, err := r.services.inventoryManagementService.RegisterEnergyResource(ctx, input)
	if err != nil {
		return nil, err
	}

	energyResource := pb.FromProto(response, &model.EnergyResource{})

	energyResource.Producer = pb.FromProto(user, &model.User{})

	return energyResource, nil
}

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, in *model.RegisterUser) (*model.User, error) {
	input := pb.ToProto(in, &pb.RegisterUserInput{})
	input.Id = uuid.New().String()

	user, err := r.services.userManagementService.RegisterUser(ctx, input)
	if err != nil {
		return nil, err
	}

	return pb.FromProto(user, &model.User{}), nil
}

// PurchaseEnergy is the resolver for the purchaseEnergy field.
func (r *mutationResolver) PurchaseEnergy(ctx context.Context, in *model.PurchaseEnergy) (*model.EnergyResource, error) {
	energyResource, err := r.services.inventoryManagementService.ReserveEnergyCapacity(
		ctx, &pb.ReservedEnergyCapacity{
			Id:               uuid.New().String(),
			EnergyResourceId: in.ID,
			ConsumerId:       in.ConsumerID,
			Capacity:         float32(in.Capacity),
			Status:           "requested",
		},
	)
	if err != nil {
		return nil, err
	}

	// Subtract reserved capacity from total capacity
	for _, reserved := range energyResource.ReservedCapacity {
		energyResource.Capacity -= reserved.Capacity
	}

	output := pb.FromProto(energyResource, &model.EnergyResource{})

	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
		Id: ptr(energyResource.ProducerId),
	})
	if err != nil {
		return nil, fmt.Errorf("user with provided id %q MUST exist", energyResource.ProducerId)
	}

	output.Producer = pb.FromProto(user, &model.User{})

	return output, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	response, err := r.services.userManagementService.FetchAllUsers(ctx, &emptypb.Empty{})
	if err != nil {
		return nil, err
	}

	var output []*model.User
	for _, user := range response.Users {
		output = append(output, pb.FromProto(user, &model.User{}))
	}

	return output, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{Id: &id})
	if err != nil {
		return nil, err
	}

	return pb.FromProto(user, &model.User{}), nil
}

// EnergyResources is the resolver for the energy_resources field.
func (r *queryResolver) EnergyResources(ctx context.Context) ([]*model.EnergyResource, error) {
	response, err := r.services.inventoryManagementService.FetchAllEnergyResources(ctx, &emptypb.Empty{})
	if err != nil {
		return nil, err
	}

	var output []*model.EnergyResource
	for _, er := range response.EnergyResources {
		// Subtract reserved capacity from total capacity
		for _, reserved := range er.ReservedCapacity {
			er.Capacity -= reserved.Capacity
		}

		// Convert from energy resource proto
		energyResource := pb.FromProto(er, &model.EnergyResource{})

		// Fetch energy producer
		producer, err := r.services.userManagementService.FetchUser(ctx, &pb.FetchUserInput{
			Id: ptr(er.ProducerId),
		})
		if err != nil {
			r.logger.Errorf("error fetching producer for energy resource %q: %s", er.Id, err)
			continue
		}

		// Convert to producer model
		energyResource.Producer = pb.FromProto(producer, &model.User{})

		output = append(output, energyResource)
	}

	return output, nil
}

// Mutation returns runtime.MutationResolver implementation.
func (r *Resolver) Mutation() runtime.MutationResolver { return &mutationResolver{r} }

// Query returns runtime.QueryResolver implementation.
func (r *Resolver) Query() runtime.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
